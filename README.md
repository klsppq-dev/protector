# Protector (Blue Team)

**Protector** — это пользовательская система защиты и контроля целостности для C/C++ приложений.  
Проект предназначен для повышения устойчивости бинарных файлов к:

- статическому анализу;
- отладке;
- патчингу;
- подмене библиотек;
- вмешательству в процесс выполнения.

Protector реализован полностью в user-space на языке C и **не требует модификации ядра**, специальных привилегий или сторонних DRM-решений.  
Основная цель проекта — **существенно повысить стоимость атаки** на приложение, а не заявлять абсолютную неуязвимость (что в пользовательском пространстве невозможно).

---

## Что делает Protector

Protector внедряется в приложение в виде защитного ядра и динамического модуля и автоматически выполняет набор проверок:

- обнаружение отладки и трассировки;
- проверка целостности исполняемого файла;
- анализ среды выполнения процесса;
- взаимная верификация компонентов защиты.

При обнаружении аномалий приложение переводится в **деградированный режим** (poisoned state), уже в котором приложение может выбирать дальнейшие действия (экстренное выключение).

---

## Архитектура и принцип работы

Protector состоит из двух ключевых компонентов:

### 1. `libhardcore.a` (статическая библиотека)

`libhardcore.a` — это **защитное ядро**, которое:

- статически линкуется с целевым приложением;
- всегда присутствует в бинаре;
- инициализируется автоматически через `constructor`-функции;
- выполняет ранние проверки среды и целостности.

Основные задачи `libhardcore.a`:
- запуск защитной логики как можно раньше;
- загрузка динамического модуля защиты;
- контроль общего состояния защиты (`poisoned / non-poisoned`).

Для гарантированной линковки используется `--whole-archive`.

---

### 2. `libhardening.so` (динамическая библиотека)

`libhardening.so` — это **дополнительный защитный модуль**, который:

- загружается во время выполнения через `dlopen`;
- имеет скрытую таблицу символов (по умолчанию `hidden`);
- экспортирует минимальный публичный API;
- выполняет дополнительные проверки и вычисления.

Основная цель `.so` — усложнить статический анализ и создать дополнительную точку отказа при попытке обхода защиты.

---

### Взаимодействие компонентов (Round-Trip Validation)

Ключевая архитектурная особенность Protector — **взаимная верификация** между `libhardcore.a` и `libhardening.so`.

Упрощённо:

1. Статическое ядро загружает `.so`.
2. Передаёт динамическому модулю секретное значение (challenge).
3. `.so` вычисляет ответ и возвращает его.
4. Ядро проверяет корректность ответа.

Таким образом:
- нельзя просто удалить `.so`;
- нельзя подменить `.so` заглушкой;
- нельзя отключить одну сторону без обнаружения другой.

Нарушение протокола → немедленный переход в poisoned-состояние.

---

## Реализованные защитные механизмы

### 1. Обнаружение отладки и трассировки

Protector выполняет проверки, направленные на выявление отладчиков и инструментов динамического анализа:

- анализ `/proc/self/status` (TracerPid);
- попытки использования `ptrace`;
- выявление аномального поведения процесса.

При обнаружении признаков отладки защита активируется немедленно.

---

### 2. Проверка целостности исполняемого файла (CRC32)

Protector вычисляет CRC32 собственного исполняемого файла, считывая байты через `/proc/self/exe`.

Особенности реализации:
- используется **CRC32-алгоритм**;
- применяется **статический XOR-ключ**;
- проверка выполняется в ранней фазе выполнения.

Это позволяет обнаруживать:
- патчинг бинаря;
- NOP-инг инструкций;
- подмену секций;
- модификацию файла на диске.

---

### 3. Анализ карты памяти процесса

Protector анализирует `/proc/self/maps` и выявляет:

- подозрительные `rwx`-регионы;
- аномальные отображения библиотек;
- runtime-инъекции и хуки.

Данный механизм позволяет обнаруживать вмешательство, которое не отражается в бинаре на диске.

---

## Структура проекта
- `/src` - исходный код Protector
- `/app` - пример приложения, использующий Protector
- `/hashgen` - программа, генерирующая CRC32 хеш, используя XOR ключ

## Включение DEBUG-вывода
Для включения/выключения DEBUG-вывода в `src/CMakeLists.txt` разкомментируйте/закомментируйте строки:
```
target_compile_definitions(hardcore PRIVATE PROTECTOR_LOG_ENABLED=1)
target_compile_definitions(hardening PRIVATE PROTECTOR_LOG_ENABLED=1)
```

Не забудьте после изменить CRC32 хеш (см. далее)

## Интегрирование в существующий проэкт
1. Замените XOR ключ в `/src/hardening/init.c` на случайный:
```c
#define PROTECTOR_STATIC_KEY <ключ>
```
2. Скомпилируйте ваш проэкт, включив в него библиотеку. 
```bash
mkdir build
cmake -S . -B build
cmake --build build
```
3. В папке build вы найдете ваш исполняемый файл (для проэкта-примера `/app`, путь файла - `/build/app/app`). Запустите программу `protector-hashgen` (`/build/hashgen/protector-hashgen`), указав аргументы: XOR ключ, указанный в `src/hardening/init.c`, и путь до исполняемого файла программы. На выходе вы получите CRC32 хэш программы.
4. Замените в файле `/src/hardening/init.c` в функции `void hardening_init(uint64_t secret)` переменную `correct_hash` на новый CRC32 хэш программы.
5. Перекомпилируйте программу.

ВАЖНО: при запуске вашей программы библиотека `libhardening.so` должна находится в той же папке, где и находится исполняемый файл программы.
